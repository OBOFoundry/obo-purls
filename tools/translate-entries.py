#!/usr/bin/env python3
#
# Reads a YAML file with a `base_url` and a list of `entries`
# and writes Apache mod_alias RedirectMatch directives. See:
#
# https://httpd.apache.org/docs/2.4/mod/mod_alias.html
#
# There are three types of entries:
#
# - exact: match an exact URL string
#   and redirect to an exact URL
# - prefix: match a URL prefix string,
#   from the start of the request URL,
#   and redirect to the "replacement" field plus
#   any string following the prefix in the request
# - regex: use any regular expression
#   allowed by RedirectMatch
#
# Entries can have these fields:
#
# - exact/prefix/regex: the URL string or regex to match;
#   exactly one required;
#   should begin with a slash "/" except for some regexs
# - replacement: the URL string or regex to redirect to;
#   exactly one required
# - status: HTTP status for redirect;
#   zero or one value; defaults to "temporary";
#   can be "permanent" (301) or "temporary" (302);
#   (Apache uses "temp" for "temporary")
# - tests: an optional list of tests
#   each test requires a `from` value, like `exact`,
#   and a `to` value, like `replacement`
#
# See the `tools/config.schema.yml` for more details.
#
# For the "exact" and "prefix" types,
# the URL strings are rewritten as escaped regular expressions,
# with a "^base_url" prefix and a "$" suffix.
# Any regular expression special characters (e.g. ., *, ?, [])
# will be escaped: they will not match as regular expressions.
#
# For the "prefix" type, "(.*)" is also appended to the "prefix" field
# and "$1" is appended to the "to" field,
# to configure the prefix match.
#
# For the "regex" type, the "" and "to" fields
# are assumed to be valid regular expressions,
# **including** the `base_url`,
# and are not checked or modified.
#
# **Only** use "regex" if "exact" or "prefix" are insufficient.
#
# The order of YAML objects will be the order
# of the Apache directives.
# If no entries are found,
# the generated file will have a header comment
# without any directives.

import argparse, sys, yaml, re
from urllib.parse import unquote

header_template = '''# DO NOT EDIT THIS FILE!
# Automatically generated from "%s".
# Edit that source file then regenerate this file.

'''

# Parse command line arguments,
# read entries from the YAML file,
# and write the Apache .htaccess file.
def main():
  parser = argparse.ArgumentParser(description='Translate YAML `entries` to .htaccess')
  parser.add_argument('yaml_file',
      type=argparse.FileType('r'),
      default=sys.stdin,
      nargs='?',
      help='read from the YAML file (or STDIN)')
  parser.add_argument('htaccess_file',
      type=argparse.FileType('w'),
      default=sys.stdout,
      nargs='?',
      help='write to the .htaccess file (or STDOUT)')
  args = parser.parse_args()

  # Load YAML document and look for 'entries' list.
  document = yaml.load(args.yaml_file)

  if not 'base_url' in document \
      or type(document['base_url']) is not str:
    raise ValueError('YAML document must contain "base_url" string')
  base_url = document['base_url']

  args.htaccess_file.write(header_template % args.yaml_file.name)

  if 'entries' in document and type(document['entries']) is list:
    i = 0
    for entry in document['entries']:
      i += 1
      args.htaccess_file.write(process_entry(base_url, i, entry) + '\n')


def clean_source(s):
  """Given a URL string,
  return an escaped regular expression for matching that string.
  Only forward-slashes are not escaped."""
  r = s.strip()
  r = re.escape(r)
  r = r.replace('\\/', '/')
  return r


def process_entry(base_url, i, entry):
  """Given a base URL, an index, and an entry dictionary,
  ensure that the entry is valid,
  and return an Apache RedirectMatch directive string."""
  source = ''
  replacement = ''

  # Check entry data type
  if type(entry) is not dict:
    raise ValueError('Entry %d is not a YAML map: "%s"' % (i, entry))

  # Validate "replacement" field
  if not 'replacement' in entry \
      or entry['replacement'] is None \
      or entry['replacement'].strip() == '':
    raise ValueError('Missing "replacement" field for entry %d' % i)

  # Determine the type for this entry.
  types = []
  if 'exact' in entry:
    source = '(?i)^%s%s$' % (base_url, clean_source(entry['exact']))
    replacement = entry['replacement']
    types.append('exact')
  if 'prefix' in entry:
    source = '(?i)^%s%s(.*)$' % (base_url, clean_source(entry['prefix']))
    replacement = entry['replacement'] + '$1'
    types.append('prefix')
  if 'regex' in entry:
    source = entry['regex']
    replacement = entry['replacement']
    types.append('regex')

  # Ensure that there is no more than one "type" key.
  if len(types) < 1:
    raise ValueError('Entry %d does not have a type; see "replacement: %s"'
        % (i, entry['replacement']))
  elif len(types) > 1:
    raise ValueError('Entry %d has multiple types: %s; see "replacement: %s"'
        % (i, ', '.join(types), entry['replacement']))

  # Validate status code
  status = 'temporary'
  if 'status' in entry:
    if entry['status'] in ('permanent', 'temporary', 'see other'):
      status = entry['status']
    else:
      raise ValueError('Invalid status "%s" for entry %d' % (entry['status'], i))

  # Switch to Apache's preferred names
  if status == 'temporary':
    status = 'temp'
  elif status == 'see other':
    status = 'seeother'

  source = unquote(source)
  replacement = unquote(replacement)

  return 'RedirectMatch %s "%s" "%s"' % (status, source, replacement)


if __name__ == "__main__":
    main()
